// Generated by CoffeeScript 1.6.2
(function() {
  var create, createElem, jsonClass;

  jsonClass = function() {
    var sockjs, sockjs_url;

    sockjs_url = "/s/polls";
    sockjs = new SockJS(sockjs_url);
    sockjs.onopen = function() {
      return console.log("connected with " + sockjs.protocol);
    };
    sockjs.onmessage = function(e) {
      return console.log(e.data);
    };
    sockjs.onclose = function() {
      return console.log("closed " + sockjs.protocol);
    };
    return this.bindClick = function() {
      return $("#_doPollCampaigns").on("click", function() {
        return sockjs.send(JSON.stringify($('form[data-pjax]').html()));
      });
    };
  };

  $.fn.serializeObject = function() {
    var json, patterns, push_counters,
      _this = this;

    json = {};
    push_counters = {};
    patterns = {
      validate: /^[a-zA-Z][a-zA-Z0-9_]*(?:\[(?:\d*|[a-zA-Z0-9_]+)\])*$/,
      key: /[a-zA-Z0-9_]+|(?=\[\])/g,
      push: /^$/,
      fixed: /^\d+$/,
      named: /^[a-zA-Z0-9_]+$/
    };
    this.build = function(base, key, value) {
      base[key] = value;
      return base;
    };
    this.push_counter = function(key) {
      if (push_counters[key] === void 0) {
        push_counters[key] = 0;
      }
      return push_counters[key]++;
    };
    $.each($(this).serializeArray(), function(i, elem) {
      var k, keys, merge, re, reverse_key;

      if (!patterns.validate.test(elem.name)) {
        return;
      }
      keys = elem.name.match(patterns.key);
      merge = elem.value;
      reverse_key = elem.name;
      while ((k = keys.pop()) !== void 0) {
        if (patterns.push.test(k)) {
          re = new RegExp("\\[" + k + "\\]$");
          reverse_key = reverse_key.replace(re, '');
          merge = _this.build([], _this.push_counter(reverse_key), merge);
        } else if (patterns.fixed.test(k)) {
          merge = _this.build([], k, merge);
        } else if (patterns.named.test(k)) {
          merge = _this.build({}, k, merge);
        }
      }
      return json = $.extend(true, json, merge);
    });
    return json;
  };

  create = function(obj) {
    var contentsObj, elem, innerElem, _i, _len, _ref;

    if ((obj.type != null) && (obj.attributes != null) && (obj.contains != null)) {
      elem = createElem(obj.type, obj.attributes);
      _ref = obj.contains;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        contentsObj = _ref[_i];
        innerElem = typeof contentsObj === 'object' ? create(contentsObj) : document.createTextNode(contentsObj);
        elem.appendChild(innerElem);
      }
      return elem;
    }
  };

  createElem = function(type, attributes) {
    var elem, key, val;

    elem = document.createElement(type);
    if (typeof attributes !== "undefined") {
      for (key in attributes) {
        val = attributes[key];
        elem.setAttribute(key, val);
      }
    }
    return elem;
  };

}).call(this);
